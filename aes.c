#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include "aes.h"

#define AES_ROUNDS 10
#define MAX_BUFFER_SIZE 1024
#define EXPANDED_KEY_SIZE 176

/**************** GLOBALS ******************/
unsigned char verbose = 0;

/*
 *************** Helper Funtions **********
 */

/**This is a helper function for key_expansion module
 * It does Rotate, S_box transformation, and Rcon tranformation
 */
void key_expansion_core_operation(unsigned char *input, unsigned char i){

    //Rotate to the left
    unsigned int *value = (unsigned int *)input;
    *value = (*value >> 8) | ((*value & 0xff) << 24);

    //S-box tranformation for four bytes
    for(unsigned char i=0; i<4; i++)
        input[i] = s[input[i]];

    //Rcon
    input[0] ^= rcon[i]; 
}


 /* This function takes 16 bytes on original key and expands it to 
 * 176 bytes
 */
void key_expansion(unsigned char *orig_key, unsigned char *expanded_key){
    if(verbose)
        printf("performing key_expansion\n");

    // DCL04-C. Do not declare more than one variable per declaration
    unsigned char bytes_cnt = 16; // 16 bytes are already generated
    unsigned char rcon_itr = 1;  // Initial values for Rcon
    
    //DCL30-C. Declare objects with appropriate storage durations
    // Here temp is defined in the scope of function and dissapears as soon 
    // as function vanishes
    unsigned char temp[4]; //Temp Storage

    for(unsigned char i=0; i<16; i++){
        expanded_key[i] = orig_key[i];
    }

    while(bytes_cnt < EXPANDED_KEY_SIZE){

        //storing last 4 of generated bytes into tempp array 
        for(unsigned char i=0; i<4; i++){
            temp[i] = expanded_key[i + bytes_cnt - 4];
        }

        if(bytes_cnt % 16 == 0){
            key_expansion_core_operation(temp, rcon_itr++);
        }

        //In this operation we basically takes first four bytes of 16 bytes 
        // and XOR with the core operation done on temp array
        for(unsigned char i=0; i<4; i++){
            expanded_key[bytes_cnt] = expanded_key[bytes_cnt-16] ^ temp[i];
            bytes_cnt++;
        }

    }


}



void sub_bytes(unsigned char **state){
    if(verbose)
        printf("performing SubBytes\n");

    for(unsigned char i=0; i<4; i++){
        for(unsigned char j=0; j<4; j++){

            unsigned char temp = state[i][j];
            state[i][j] = s[temp];          //filling the state matrix
            //printf("%u ", state[i][j]);    //printing elements of state matrix

        }
        //printf("\n");
    }
}

void rev_sub_bytes(unsigned char **state){
    if(verbose)
        printf("performing Reverse SubBytes\n");

    for(unsigned char i=0; i<4; i++){
        for(unsigned char j=0; j<4; j++){
            state[i][j] = inv_s[state[i][j]];          //filling the state matrix
        }
    }
}

void shift_rows(unsigned char **state){
    if (verbose)
        printf("performing ShiftRows\n");
    
    for(unsigned char i=1; i<4; i++){
        for(unsigned char j=1; j<=i; j++){

            unsigned char temp = state[i][0];          // shifting rows
            for(unsigned char z=0; z<3; z++){
                state[i][z] = state[i][z+1];
            
            }
            state[i][3] = temp;
        }
    }
}

void rev_shift_rows(unsigned char **state){
    if (verbose)
        printf("performing Reverse ShiftRows\n");
    
    for(unsigned char i=1; i<4; i++){
        for(unsigned char j=1; j<=i; j++){

            unsigned char temp = state[i][3];          // shifting rows
            for(unsigned char z=3; z>0; z--){
                state[i][z] = state[i][z-1];
            
            }
            state[i][0] = temp;
        }
    }   
}


void mix_columns(unsigned char **state){
    
    unsigned char sum;
    if(verbose)
        printf("performing MixColumns\n");

    unsigned char temp[4][4] = {0};

    //This operation is basically galilo field dot multiplication
    // and galilo field addition afterwards to get the results
    for(unsigned char col=0; col<4; col++){
        for(unsigned char row=0; row<4; row++){
            
            sum = 0x0;

            for(unsigned char k=0; k<4; k++){

                if (galmatrix[row][k] == 0x2){
                    sum ^= mul2[state[k][col]];
                    
                }else if (galmatrix[row][k] == 0x3){
                    sum ^= mul3[state[k][col]];
                    
                }else{
                    sum ^= state[k][col];

                }       
            }
            
            temp[row][col] = sum;
            // Debugging code to see if the transformation happens correctly
            //printf("col = %u, row = %u, value=%x\n", col, row, temp[row][col]);
        }
    }

    //copy the state back to state matrix from temp
    for (unsigned char i=0; i<4; i++){
        for (unsigned char j=0; j<4; j++){
            state[i][j] = temp[i][j];
        }
    }
    if(verbose)
        printf("Mix Columns done\n");

}


void rev_mix_columns(unsigned char **state){
    unsigned char sum;
    if(verbose)
        printf("performing MixColumns\n");

    unsigned char temp[4][4] = {0};

    //This operation is basically galilo field dot multiplication
    // and galilo field addition afterwards to get the results
    for(unsigned char col=0; col<4; col++){
        for(unsigned char row=0; row<4; row++){
            
            sum = 0x0;

            for(unsigned char k=0; k<4; k++){

                if (inv_galmatrix[row][k] == 0x9){
                    sum ^= mul9[state[k][col]];
                    
                }else if (inv_galmatrix[row][k] == 0x0B){
                    sum ^= mul11[state[k][col]];
                    
                }else if (inv_galmatrix[row][k] == 0x0D){
                    sum ^= mul13[state[k][col]];
                    
                }else if (inv_galmatrix[row][k] == 0x0E){
                    sum ^= mul14[state[k][col]];
                    
                }else{}     
            }
            
            temp[row][col] = sum;
            // Debugging code to see if the transformation happens correctly
            //printf("col = %u, row = %u, value=%x\n", col, row, temp[row][col]);
        }
    }

    //copy the state back to state matrix from temp
    for (unsigned char i=0; i<4; i++){
        for (unsigned char j=0; j<4; j++){
            state[i][j] = temp[i][j];
        }
    }
    if(verbose)
        printf("Mix Columns done\n");
}


void add_roundkey(unsigned char **state, unsigned char *key){
    
    if(verbose)
        printf("performing AddRoundKey\n");
    
    unsigned char z = 0;
    for(unsigned char i=0; i<4; i++){
        for(unsigned char j=0; j<4; j++){
            state[j][i] ^= key[z++];
        
        }
    }
}


void print(unsigned char **state){
    for(unsigned char i=0; i<4; i++){
        for (unsigned char j=0; j<4; j++){
            printf("0x%02x, ", state[i][j]);
        }
        printf("\n");
    }
}


void print_arr(unsigned char *arr, int len){
    for(int i=0; i<len; i++)
        printf("0x%02x ", arr[i]);
    printf("\n");
}


/****** Encryption Function ****************/
void aes_encrypt_func(unsigned char *msg, unsigned char *key, unsigned char len){

    unsigned char number_of_rounds = AES_ROUNDS - 1;  //since final round is written separately
    unsigned char k = 0;
    unsigned char z = 0;
    unsigned char block = 0;

    // MEM05-C. Avoid large stack allocations
    // Avoided large stack allocations by dynamically allocating memory
    // dynamically allocating state matrix
    unsigned char **state = malloc(4 * sizeof(char *));
    for(int i=0; i<4; i++){
        state[i] = malloc(4 * sizeof(char));
    }

    // MEM05-C. Avoid large stack allocations
    //dynamically allocate expanded key
    unsigned char *expanded_key = malloc(EXPANDED_KEY_SIZE * sizeof(char));

    //creating input blocks and performing aes rounds for encryption
    while (z<len)
    { 
        for (unsigned char i=0; i<4; i++){
            for (unsigned char j=0; j<4; j++){
                if (msg[z] != '\0'){
                    //filling the state matrix for round 1. Before round 1 state matrix and input matrix are same
                    state[j][i] = msg[z];
                    z++;

                }
                else{                             
                    //padding the state matrix with 0 to complete a block.
                    state[j][i]='\0';

                }
            }
        }

        block++;
        if(verbose)
            printf("No. of blocks %d\n" ,block);    //printing the number of blocks


        // 1st step: Key expansion
        if(verbose)
            printf("Performing Key Expansion & AddRound Key\n");
        
        // expanding the key at once and then reusing it in cycles
        // normal key is added since the function has linear association
        key_expansion(key, expanded_key);
    
        add_roundkey(state, key);
        
        // 2nd step: Rounds
        // Key expansion is followed by rounds which contains following substeps
        //      a. SubBytes
        //      b. ShiftRows
        //      c. MixColumns
        //      d. AddRoundKey
        if(verbose)
            printf("Performing Rounds\n");
        
        for(unsigned char i=1; i<=number_of_rounds; i++){
            if(verbose)
                printf("\nRound %d\n",i);

            sub_bytes(state);
            shift_rows(state);
            mix_columns(state);
            add_roundkey(state, expanded_key + 16 * i);
            
            if(verbose)
                print(state);

        }

        // 3rd step: Final Round
        // It is similar to previous rounds except it doesn't
        // contain the [c]MixColumn step
        if(verbose)
            printf("performing Final Round %d:\n", AES_ROUNDS);
        
        sub_bytes(state);
        shift_rows(state);
        add_roundkey(state, expanded_key + 16 * AES_ROUNDS);

        //This code return the cipher in message block only since message 
        if(verbose){
            printf("The Encryption of Block %d \n", block);
            print(state);   
        }
        
        for(unsigned char i=0; i<4; i++)
            for(unsigned char j=0; j<4; j++)
                msg[k++] = state[j][i];

    }
    // MEM31-C. Free dynamically allocated memory when no longer needed
    //Freeing up the state matrix space
    for(int i=0; i<4; i++)
        free(state[i]);
    free(state);

    // MEM31-C. Free dynamically allocated memory when no longer needed
    //free expanded key size
    free(expanded_key);
    
}


/********* Decryption Function *************/
/* Decryption Function for AES,
 * This function takes in cipher text and key and  returns the the original 
 * message block
 */
void aes_decrypt_func(unsigned char *cipher, unsigned char *key, unsigned char len){
    

    unsigned char z=0;
    unsigned char k=0;
    
    //dynamically allocating state matrix
    unsigned char **state = malloc(4 * sizeof(char *));
    for(int i=0; i<4; i++){
        state[i] = malloc(4 * sizeof(char));
    }

    //dynamically allocate expanded key
    unsigned char *expanded_key = malloc(EXPANDED_KEY_SIZE * sizeof(char));

    while (z<len){
        //rearrange blocks in cipher for adjustment
        for(unsigned char i=0; i<4; i++)
            for(unsigned char j=0; j<4; j++)
                state[j][i] = cipher[z++];

        key_expansion(key, expanded_key);

        add_roundkey(state, expanded_key + 16 * AES_ROUNDS);
        rev_shift_rows(state);
        rev_sub_bytes(state);

        for(unsigned char i=AES_ROUNDS-1; i>=1; i--){
            add_roundkey(state, expanded_key + 16 * i);
            rev_mix_columns(state);
            rev_shift_rows(state);
            rev_sub_bytes(state);
        }

        add_roundkey(state, key);

        //Once done just return original message in cipher area only
        for(unsigned char i=0; i<4; i++)
            for(unsigned char j=0; j<4; j++)
                cipher[k++] = state[j][i];
    }

    // MEM31-C. Free dynamically allocated memory when no longer needed
    //Freeing up the state matrix space
    for(int i=0; i<4; i++)
        free(state[i]);
    free(state);

    // MEM31-C. Free dynamically allocated memory when no longer needed
    //free expanded key size
    free(expanded_key);
}


/********* Verification module *************/
/* This was a test module to verify key expansion 
 */
void verify_key_expansion(){
    unsigned char key[16] ={ 0x2b ,0x7e ,0x15 ,0x16 ,0x28 ,0xae ,0xd2 ,0xa6 ,0xab ,0xf7 
        ,0x15 ,0x88 ,0x09 ,0xcf ,0x4f ,0x3c};

    unsigned char expanded_key[EXPANDED_KEY_SIZE];

    key_expansion(key, expanded_key);

    for(unsigned char i=0; i<176; i++){
        if(i%4 == 0) printf("\n");
        printf("%x ", expanded_key[i]);
    }
}


/********** Main Program ***********************/
int main()
{

    unsigned char * p;
    int len = 0;
    unsigned char message[MAX_BUFFER_SIZE];
    unsigned char key[16];
    struct timespec ts;

    // unsigned char message[MAX_BUFFER_SIZE] = { 0x32, 0x43, 0xf6, 0xa8,
    //                          0x88, 0x5a, 0x30, 0x8d,
    //                          0x31, 0x31, 0x98, 0xa2, 
    //                          0xe0, 0x37, 0x07, 0x34};

    // unsigned char key[16] = { 0x2b, 0x7e, 0x15, 0x16,
    //                        0x28, 0xae, 0xd2, 0xa6, 
    //                        0xab, 0xf7, 0x15, 0x88,
    //                        0x09, 0xcf, 0x4f, 0x3c
    //                      };

    //unsigned char cipher[] = {    0x39, 0x25, 0x84, 0x1d, 
    //                          0x2,  0xdc, 0x9,  0xfb, 
    //                          0xdc, 0x11, 0x85, 0x97, 
    //                          0x19, 0x6a, 0xb, 0x32,};
    


    //Message contains newline implicitly
    fgets(message, MAX_BUFFER_SIZE, stdin);
    if((p=strchr(message, '\n')) != NULL){
        *p = '\0';
    }
    
    len = strlen(message);
    

    // MSC30-C. Do not use the rand() function for generating pseudorandom numbers
    // we should use POSIX random() function instead of rand() which provides better randomness
    // and avoids predictable keys

    // MSC32-C. Properly seed pseudorandom number generators
    // srandom is used to seed PRG here i.e random()

    //Generate Random Key
    if (timespec_get(&ts, TIME_UTC) == 0) {
        /* Handle error */
        printf("Error populating time specs\n");
        return 1;

    } else {
        srandom(ts.tv_nsec ^ ts.tv_sec);
        for (unsigned char i=0; i<16; ++i) {
            /* Generates different sequences at different runs */
            key[i] = random();
        }
    }    

    printf("Generated Random key: \n");
    print_arr(key, 16);

    clock_t begin = clock();
    //printf("Length of message = %d\n", strlen(message));
    aes_encrypt_func(message, key, len);
    
    clock_t end = clock();
    double time = (double)(end - begin) / CLOCKS_PER_SEC;

    printf("\nTime taken for Encryption: %lf ms\n", time*1000);
    printf("Encrypted Message in HEX:\n");
    print_arr(message, len);

    printf("Encrypted Message in ASCII:\n");
    printf("%s\n",(message));


    printf("\n\n");

    begin = clock();
    
    aes_decrypt_func(message, key, len);

    end = clock();
    time = (double)(end - begin) / CLOCKS_PER_SEC;

    printf("Time taken for Decryption: %lf ms\n", time*1000);
    
    printf("Decrypted Message in HEX\n"); 
    print_arr(message, len);

    printf("Decrypted Message in ASCII\n");
    // Add '\0' to make sure printf prints the ascii text correctly
    message[len] = '\0';

    // STR32-C. Do not pass a non-null-terminated character sequence to a library function that expects a string
    printf("%s\n",(message));

    //verify_key_expansion();
    
    return 0;
}
